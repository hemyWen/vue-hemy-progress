<!--
 * @Author: whm
 * @Date: 2022-08-04 11:39:56
 * @LastEditTime: 2022-08-04 11:52:50
 * @Description: 
-->
<!-- svg element made up of two overlapping path elements
both elements are animated in their d attribute
the second is also animated through the stroke-dasharray and stroke-dashoffset properties to progressively draw in the colored shape
-->
<svg id="progress" viewBox="0 0 100 100" width="100" height="100">
  <g
    fill="none"
    stroke-width="7"
    stroke-linecap="round"
    stroke-linejoin="round"
    transform="translate(5 5) scale(0.9 0.9)"
  >
    <path stroke="hsl(0, 0%, 0%)" opacity="0.5" d="M 0 50 100 50"></path>
    <path stroke="currentColor" d="M 0 50 100 50"></path>
  </g>
</svg>

<!-- buttons used to modify the appearance of the path elements
- sectioned in two containers, each describing the purpose through an SVG icon
- included through JavaScript, one for each option
-->
<div class="controls">
  <!-- controls to modify the color -->
  <div class="controls__color">
    <!-- icon resembling a color palette -->
    <svg viewBox="0 0 100 100" width="50" height="50">
      <!-- cut out parts of the circle to describe the curvy silhouette of the color palette -->
      <defs>
        <mask id="mask">
          <rect x="0" y="0" width="100" height="100" fill="#fff"></rect>

          <circle cx="50" cy="20" r="8" fill="hsl(0, 0%, 0%)"></circle>

          <circle cx="72" cy="35" r="8" fill="hsl(0, 0%, 0%)"></circle>
          <circle cx="28" cy="35" r="8" fill="hsl(0, 0%, 0%)"></circle>

          <path
            d="M 40 70 a 10 10 0 0 1 20 0 a 15 15 0 0 0 30 0 v 30 h -80 v -30 a 15 15 0 0 0 30 0"
            fill="hsl(0, 0%, 0%)"
          ></path>
        </mask>
      </defs>

      <g transform="translate(50 50) rotate(50)">
        <g transform="translate(-50 -50)">
          <circle mask="url(#mask)" cx="50" cy="50" r="45" fill="hsl(0, 0%, 0%)"></circle>
        </g>
      </g>
    </svg>
  </div>

  <!-- controls to modify the shape -->
  <div class="controls__shape">
    <!-- icon resembling the pen tool -->
    <svg viewBox="0 0 100 100" width="50" height="50">
      <!-- rotate the icon toward the matching buttons -->
      <g transform="translate(50 50) rotate(30)">
        <g transform="translate(-50 -50)">
          <path
            fill="none"
            stroke-linejoin="round"
            stroke-linecap="round"
            stroke-width="10"
            stroke="hsl(0, 0%, 0%)"
            d="M 40 20 h 20 l 20 30 l -30 40 v -40 v 40 l -30 -40 l 20 -30 v -10 h 20 v 10"
          ></path>
        </g>
      </g>
    </svg>
  </div>
</div>
<style>
  * {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }
  /* display the elements in a column, horizontally centered */
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #16132f;
    color: hsl(252, 65%, 63%);
  }
  /* size the larger svg to encompass a considerable portion of the viewport */
  svg#progress {
    width: 300px;
    height: 300px;
    /* fill dictated by the color set on the body */
    fill: currentColor;
    /* transition for the change in color */
    transition: color 0.2s ease-in-out;
    margin: 2rem 0;
  }

  /* display the icon and buttons in a row */
  .controls__color,
  .controls__shape {
    margin: 2.5rem 0;
    display: flex;
    justify-content: center;
    align-items: center;
    /* position relative to absolute position the svg icons */
    position: relative;
  }
  /* absolute position the first icon of each container to its side */
  .controls__color > svg,
  .controls__shape > svg {
    position: absolute;
    top: 50%;
    right: 100%;
    transform: translate(0%, -50%);
    opacity: 0.5;
    width: 70px;
    height: 70px;
  }
  /* second icon to the right of the container */
  .controls__shape > svg {
    right: 0;
    transform: translate(100%, -50%);
  }

  /* style the buttons to remove the default background and border */
  .controls__color button,
  .controls__shape button {
    color: currentColor;
    width: 32px;
    height: 32px;
    background: none;
    border: none;
    border-radius: 50%;
    margin: 0.75rem;
  }
  /* expand the nested svg to occupy as much space as allocated by the button elements */
  .controls__color button svg,
  .controls__shape button svg {
    display: block;
    width: 100%;
    height: 100%;
    /* transition for the change in color */
    transition: color 0.2s ease-in-out;
  }

  /* animation for the colored path */
  @keyframes drawPath {
    to {
      stroke-dashoffset: 0;
    }
  }
</style>
<script src="./anime.min.js"></script>
<script>
  // colors updating the SVG through the currentColor property
  const colors = [
    'hsl(166, 100%, 55%)',
    'hsl(38, 100%, 60%)',
    'hsl(316, 98%, 59%)',
    'hsl(273, 100%, 68%)',
    'hsl(252, 65%, 63%)'
  ]

  /** syntax updating the SVG through the d attribute
   * horizontal line
   * heart rate
   * lightning bolt
   * star
   * hourglass
   */
  // the coordinates describe absolute points followed by the path element
  // ! remember the M command at the beginning of the d attribute
  const shapes = [
    '0 50 100 50',
    '0 50 12.5 50 18.75 65.5 25 50 37.5 50 43.75 34.1 56.25 60.87 62.5 50 68.75 50 75 15.38 81.25 50 87.5 50 93.75 71.33 100 50',
    '50 0 80 0 60 30 75 30 45 70 70 70 20 100 35 70 20 70 45 30 30 30 50 0',
    '50 10 65 40 90 40 70 60 80 90 50 75 20 90 30 60 10 40 35 40 50 10',
    '15 15 85 15 15 85 85 85 15 15'
  ]

  // ! to smoothly animate between the shapes it is necessary to maintain a consistent number of points
  const pointRegex = /[\d\.]+ [\d\.]+/gi
  // create an array describing the points of each shape
  const points = shapes.map((shape) => shape.match(pointRegex))
  // create an array detailing the length of the points' array, for each shape
  const pointsLength = points.map((point) => point.length)
  // retrieve the highest number of points
  const maxPoint = [...pointsLength].sort((a, b) => (a > b ? -1 : 1))[0]

  // create an array of shapes adding to each string as many points to make up the difference between the shapes's points and the maximum amount
  // include copies of the last point
  const fixedShapes = shapes.map((shape, index) => {
    const difference = maxPoint - pointsLength[index]
    const lastPoint = points[index][points[index].length - 1]
    const addendum = ` ${lastPoint}`
    return `${shape}${addendum.repeat(difference)}`
  })

  // function updating the color property set on the body
  const updateColor = (color) => {
    document.querySelector('body').style.color = color
  }

  // function updating the stroke-dash properties to match the length of the input element
  const updateDash = (path) => {
    const length = path.getTotalLength()
    path.setAttribute('stroke-dasharray', length)
    path.setAttribute('stroke-dashoffset', length)
  }

  // function updating the d attribute of both path elements
  const updateShape = (shape) => {
    const paths = document.querySelectorAll('svg#progress g path')
    anime({
      targets: paths,
      d: `M ${shape}`,
      duration: 800,
      // as you animate the points attribute update the stroke-dash properties with the new length of the path
      update() {
        updateDash(paths[1])
      },
      easing: 'easeInOutCirc'
    })
  }

  // target the path elements and single out the colored one
  const progressPaths = document.querySelectorAll('svg#progress g path')
  const progressPath = progressPaths[1]

  // update the d attribute with the first fixed value
  progressPaths.forEach((path) => path.setAttribute('d', `M ${fixedShapes[0]}`))

  // update the dash properties on the colored path
  updateDash(progressPath)

  // begin the endless animation to draw the colored path and and out of sight
  progressPath.style.animation = 'drawPath 7s ease-in-out infinite alternate'

  // for the controls include one button for each color, one button for each shape
  const controls = document.querySelector('.controls')
  const controlsColor = controls.querySelector('.controls__color')
  const controlsShape = controls.querySelector('.controls__shape')

  // for each color add a button to update the path element with the prescribed hue
  colors.forEach((color) => {
    const button = document.createElement('button')
    button.addEventListener('click', () => updateColor(color))
    // in the button include a circle matching the input color
    button.innerHTML = `
  <svg viewBox="0 0 100 100" width="50" height="50">
    <circle
        cx="50"
        cy="50"
        r="50"
        fill="${color}">
    </circle>
  </svg>`

    controlsColor.appendChild(button)
  })

  // for each shape add a button to change both path elements with the connected points attribute
  fixedShapes.forEach((shape) => {
    const button = document.createElement('button')
    button.addEventListener('click', () => updateShape(shape))
    // ! use the currentColor property to match the selected color
    // ! use a larger viewBox to reduce the size of the path elements
    button.innerHTML = `
  <svg viewBox="0 0 150 150" width="50" height="50">
    <g
      transform="translate(25 25)">
      <path
        fill="none"
        stroke="currentColor"
        stroke-width="20"
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M ${shape}">
      </path>
    </g>
  </svg>`

    controlsShape.appendChild(button)
  })
</script>
